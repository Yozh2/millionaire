/**
 * HeaderSlideshow - Animated background slideshow for game header.
 * Shows themed images with smooth cross-fade transitions and
 * additive blend mode for a dramatic glowing effect.
 *
 * Supports two modes:
 * 1. Explicit images in config
 * 2. Auto-load from manifest.json (generated by build script)
 */

import { useState, useEffect, useCallback, useRef } from 'react';
import type {
  HeaderSlideshowConfig,
  HeaderSlideshowImages,
  QuestionDifficulty,
} from '../types';

interface HeaderSlideshowProps {
  /** Slideshow configuration */
  config: HeaderSlideshowConfig;
  /** Current question difficulty level */
  difficulty: QuestionDifficulty;
  /** Game ID for asset path resolution */
  gameId: string;
}

/** Empty images placeholder */
const EMPTY_IMAGES: HeaderSlideshowImages = {
  easy: [],
  medium: [],
  hard: [],
};

/**
 * Resolves image path with game-specific prefix.
 */
const getImagePath = (gameId: string, imagePath: string): string => {
  // If path already starts with / or http, use as-is
  if (imagePath.startsWith('/') || imagePath.startsWith('http')) {
    return imagePath;
  }
  // Otherwise prefix with game assets path
  return `/games/${gameId}/images/${imagePath}`;
};

/**
 * Load manifest.json from game's images directory.
 */
const loadManifest = async (
  gameId: string
): Promise<HeaderSlideshowImages | null> => {
  try {
    const response = await fetch(`/games/${gameId}/images/manifest.json`);
    if (!response.ok) return null;
    const data = await response.json();
    return {
      easy: data.easy || [],
      medium: data.medium || [],
      hard: data.hard || [],
    };
  } catch {
    return null;
  }
};

/**
 * HeaderSlideshow component displays a background slideshow
 * with cross-fade transitions and additive blend mode.
 */
export const HeaderSlideshow: React.FC<HeaderSlideshowProps> = ({
  config,
  difficulty,
  gameId,
}) => {
  const {
    enabled = true,
    images: configImages,
    transitionDuration = 1500,
    displayDuration = 4000,
    opacity = 0.4,
  } = config;

  // State for loaded images (from config or manifest)
  const [images, setImages] = useState<HeaderSlideshowImages>(
    configImages || EMPTY_IMAGES
  );
  const [isLoading, setIsLoading] = useState(!configImages);

  // Load manifest if no explicit images provided
  useEffect(() => {
    if (configImages) {
      setImages(configImages);
      setIsLoading(false);
      return;
    }

    if (!enabled) {
      setIsLoading(false);
      return;
    }

    loadManifest(gameId).then((manifest) => {
      if (manifest) {
        setImages(manifest);
      }
      setIsLoading(false);
    });
  }, [gameId, configImages, enabled]);

  // Get images for current difficulty (fallback to easier levels)
  const currentImages =
    images[difficulty]?.length > 0
      ? images[difficulty]
      : images.medium?.length > 0
        ? images.medium
        : images.easy || [];

  // State for current and next image indices
  const [currentIndex, setCurrentIndex] = useState(0);
  const [nextIndex, setNextIndex] = useState<number | null>(null);
  const [isTransitioning, setIsTransitioning] = useState(false);

  // Track last used index to avoid immediate repeats
  const lastIndexRef = useRef<number>(-1);

  // Pick a random image index, avoiding the last one
  const pickRandomIndex = useCallback(() => {
    if (currentImages.length <= 1) return 0;

    let newIndex: number;
    do {
      newIndex = Math.floor(Math.random() * currentImages.length);
    } while (newIndex === lastIndexRef.current && currentImages.length > 1);

    lastIndexRef.current = newIndex;
    return newIndex;
  }, [currentImages.length]);

  // Initialize with random image on difficulty change
  useEffect(() => {
    if (currentImages.length === 0) return;
    const initialIndex = pickRandomIndex();
    setCurrentIndex(initialIndex);
    setNextIndex(null);
    setIsTransitioning(false);
  }, [difficulty, currentImages.length, pickRandomIndex]);

  // Slideshow timer
  useEffect(() => {
    if (currentImages.length <= 1) return;

    const cycleImage = () => {
      // Pick next random image
      const next = pickRandomIndex();
      setNextIndex(next);
      setIsTransitioning(true);

      // After transition completes, swap images
      setTimeout(() => {
        setCurrentIndex(next);
        setNextIndex(null);
        setIsTransitioning(false);
      }, transitionDuration);
    };

    const intervalId = setInterval(cycleImage, displayDuration);

    return () => clearInterval(intervalId);
  }, [
    currentImages.length,
    displayDuration,
    transitionDuration,
    pickRandomIndex,
  ]);

  // Don't render if loading, disabled, or no images
  if (isLoading || !enabled || currentImages.length === 0) return null;

  const currentImagePath = getImagePath(gameId, currentImages[currentIndex]);
  const nextImagePath =
    nextIndex !== null ? getImagePath(gameId, currentImages[nextIndex]) : null;

  return (
    <div
      className="absolute inset-0 overflow-hidden pointer-events-none"
      style={{ zIndex: 0 }}
    >
      {/* Current image */}
      <div
        className="absolute inset-0 bg-cover bg-center bg-no-repeat"
        style={{
          backgroundImage: `url(${currentImagePath})`,
          opacity: isTransitioning ? 0 : opacity,
          transition: `opacity ${transitionDuration}ms ease-in-out`,
          mixBlendMode: 'screen', // Additive-like blend
          filter: 'saturate(1.2) brightness(1.1)',
        }}
      />

      {/* Next image (fades in during transition) */}
      {nextImagePath && (
        <div
          className="absolute inset-0 bg-cover bg-center bg-no-repeat"
          style={{
            backgroundImage: `url(${nextImagePath})`,
            opacity: isTransitioning ? opacity : 0,
            transition: `opacity ${transitionDuration}ms ease-in-out`,
            mixBlendMode: 'screen', // Additive-like blend
            filter: 'saturate(1.2) brightness(1.1)',
          }}
        />
      )}

      {/* Gradient overlay for text readability */}
      <div
        className="absolute inset-0"
        style={{
          background:
            'linear-gradient(to bottom, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.6) 100%)',
        }}
      />
    </div>
  );
};

export default HeaderSlideshow;
